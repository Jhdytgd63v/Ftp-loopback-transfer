package com.sandbox.ftptransfer.service
import com.sandbox.ftptransfer.utils.AppNotificationManager

import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.util.Log
import com.sandbox.ftptransfer.utils.PortManager
import com.sandbox.ftptransfer.model.SenderSettings
import com.sandbox.ftptransfer.model.FolderMonitorConfig
import com.sandbox.ftptransfer.model.FileAction
import com.google.gson.Gson
import kotlinx.coroutines.*
import java.io.*
import java.util.Collections
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

class FileMonitorService : Service() {

    private val TAG = "FileMonitorService"
    private val isRunning = AtomicBoolean(false)
    private var monitorJob: Job? = null
    private val scope = CoroutineScope(Dispatchers.IO + Job())
    private val processedFiles = Collections.newSetFromMap(ConcurrentHashMap<String, Boolean>())
    private val lastScanTimes = ConcurrentHashMap<String, Long>() // Folder path -> Last scan time

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "FileMonitorService created")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Start foreground service untuk Android 8+
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            val channel = android.app.NotificationChannel("ftp_monitor_channel", "File Monitoring", android.app.NotificationManager.IMPORTANCE_LOW)
            val manager = getSystemService(android.app.NotificationManager::class.java)
            manager.createNotificationChannel(channel)
            
            val notification = android.app.Notification.Builder(this, "ftp_monitor_channel")
                .setContentTitle("FTP File Monitor")
                .setContentText("Monitoring folders for new files")
                .setSmallIcon(android.R.drawable.stat_sys_upload)
                .build()
            startForeground(1, notification)
        }
        if (!isRunning.getAndSet(true)) {
            startFileMonitoring()
        }
        return START_STICKY
    }

    private fun startFileMonitoring() {
        monitorJob = scope.launch {
            Log.d(TAG, "Starting file monitoring service...")

            while (isRunning.get()) {
                try {
                    val settings = loadSenderSettings()
                    val enabledConfigs = settings.monitoredFolders.filter { it.enabled }

                    enabledConfigs.forEach { config ->
                        if (shouldScanFolder(config)) {
                            monitorConfiguredFolder(config)
                        }
                    }

                    // Global check interval (1 second untuk responsiveness)
                    delay(1000)

                } catch (e: Exception) {
                    if (isRunning.get()) {
                        Log.e(TAG, "Error in file monitoring: ${e.message}")
                        delay(5000) // Wait longer if there's an error
                    }
                }
            }
        }
    }

    private fun shouldScanFolder(config: FolderMonitorConfig): Boolean {
        val now = System.currentTimeMillis()
        val lastScan = lastScanTimes[config.folderPath] ?: 0L
        val delayMs = config.monitoringSettings.getDelayMillis()
        
        return now - lastScan >= delayMs
    }

    private suspend fun monitorConfiguredFolder(config: FolderMonitorConfig) {
        try {
            // Handle both content URI and file paths
            val uri = android.net.Uri.parse(config.folderPath)
            
            if (uri.scheme == "content") {
                // Use DocumentFile for content URIs
                val documentDir = androidx.documentfile.provider.DocumentFile.fromTreeUri(this@FileMonitorService, uri)
                if (documentDir == null || !documentDir.exists() || !documentDir.isDirectory) {
                    Log.w(TAG, "Document directory not found: ${config.folderPath}")
                    return
                }
                
                // Update last scan time
                lastScanTimes[config.folderPath] = System.currentTimeMillis()
                
                val documents = documentDir.listFiles()
                var transferredCount = 0
                var filteredCount = 0
                
                for (document in documents) {
                    if (document.isFile && !processedFiles.contains(document.uri.toString())) {
                        
                        // Create temporary file object for filtering
                        val tempFile = File(cacheDir, document.name ?: "unknown")
                        
                        // AUTO DETECT FILTERING
                        if (config.shouldTransferFile(tempFile)) {
                            // Wait for file stability
                            delay(config.monitoringSettings.getDelayMillis().coerceAtMost(2000L))
                            
                            if (isDocumentReady(document)) {
                                AppNotificationManager.notifyStatus(this@FileMonitorService, document.name.hashCode(), "ðŸ“ File Detected", "New file: ${document.name}")
                                processedFiles.add(document.uri.toString())
                                scope.launch {
                                    sendDocumentToReceiver(document, config)
                                }
                                transferredCount++
                            }
                        } else {
                            filteredCount++
                            Log.d(TAG, "AutoDetect filtered: ${document.name} in ${config.folderName}")
                        }
                    }
                }
                
                // Log statistics
                if (transferredCount > 0 || filteredCount > 0) {
                    Log.i(TAG, "AutoDetect [${config.folderName}]: Transferred: $transferredCount, Filtered: $filteredCount")
                }
            } else {
                // Use regular File for filesystem paths (fallback)
                val directory = File(config.folderPath)
                if (!directory.exists() || !directory.isDirectory) {
                    Log.w(TAG, "Directory not found: ${config.folderPath}")
                    return
                }
                
                // Update last scan time
                lastScanTimes[config.folderPath] = System.currentTimeMillis()
                
                val files = directory.listFiles() ?: return
                
                var transferredCount = 0
                var filteredCount = 0
                
                for (file in files) {
                    if (file.isFile && !processedFiles.contains(file.absolutePath)) {
                        
                        // AUTO DETECT FILTERING - CORE FEATURE
                        if (config.shouldTransferFile(file)) {
                            // Wait for file to be completely written
                            delay(config.monitoringSettings.getDelayMillis().coerceAtMost(2000L))
                            
                            if (isFileReady(file)) {
                                AppNotificationManager.notifyStatus(this@FileMonitorService, file.name.hashCode(), "ðŸ“ File Detected", "New file: ${file.name}")
                                processedFiles.add(file.absolutePath)
                                scope.launch {
                                    sendFileToReceiver(file, config)
                                }
                                transferredCount++
                            }
                        } else {
                            filteredCount++
                            Log.d(TAG, "AutoDetect filtered: ${file.name} in ${config.folderName}")
                        }
                    }
                }
                
                // Log auto detect statistics
                if (transferredCount > 0 || filteredCount > 0) {
                    Log.i(TAG, "AutoDetect [${config.folderName}]: Transferred: $transferredCount, Filtered: $filteredCount")
                }
            }
            
            // Clean up processed files set to prevent memory leak
            if (processedFiles.size > 1000) {
                processedFiles.clear()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error monitoring folder ${config.folderPath}: ${e.message}")
        }
    }

    private suspend fun isFileReady(file: File): Boolean {
        return try {
            val initialSize = file.length()
            delay(1000) // Fixed 1 second untuk file stability check
            val finalSize = file.length()
            initialSize == finalSize && initialSize > 0
        } catch (e: Exception) {
            false
        }
    }

    private suspend fun sendFileToReceiver(file: File, config: FolderMonitorConfig) {
        Log.d(TAG, "Attempting to send file: ${file.name} to port: ${config.targetPort}")

        AppNotificationManager.notifyStatus(this, file.name.hashCode(), "ðŸ“¤ Sending File", "Sending ${file.name} to port ${config.targetPort}")
        // FIX: Gunakan connectToServer bukan connectToPort
        val socket = PortManager.connectToServer(config.targetPort)

        if (socket == null) {
            Log.e(TAG, "Failed to connect to server on port ${config.targetPort}")
            processedFiles.remove(file.absolutePath)
            return
        }

        try {
            socket.use { sock ->
                val outputStream = DataOutputStream(sock.getOutputStream())
                val inputStream = DataInputStream(sock.getInputStream())

                // Send file metadata
                outputStream.writeUTF(file.name)
                outputStream.writeLong(file.length())
                outputStream.writeUTF(config.fileAction.toString())

                // Send file data
                val fileInputStream = FileInputStream(file)
                val buffer = ByteArray(8192)
                var read: Int

                fileInputStream.use { fis ->
                    while (fis.read(buffer).also { read = it } != -1) {
                        outputStream.write(buffer, 0, read)
                    }
                }

                outputStream.flush()

                // Wait for response
                val success = inputStream.readBoolean()
                val message = inputStream.readUTF()
                        AppNotificationManager.notifyStatus(this, file.name.hashCode(), "âœ… Transfer Complete", "File sent: ${file.name}")

                if (success) {
                    Log.d(TAG, "File sent successfully: ${file.name} - $message")

                        if (config.fileAction == FileAction.MOVE && file.exists()) {
                            file.delete()
                            Log.d(TAG, "Source file deleted after move: ${file.name}")
                        } else {
                            // No action needed
                        }

                } else {
                    Log.e(TAG, "File transfer failed: ${file.name} - $message")
                    processedFiles.remove(file.absolutePath) // Retry later
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error sending file ${file.name}: ${e.message}")
            processedFiles.remove(file.absolutePath)
        }
    }

    private fun loadSenderSettings(): SenderSettings {
        return try {
            val settingsFile = File(filesDir, "sender_settings.json")
            if (settingsFile.exists()) {
                val json = settingsFile.readText()
                Gson().fromJson(json, SenderSettings::class.java)
            } else {
                SenderSettings() // Return default settings
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading sender settings: ${e.message}")
            SenderSettings() // Return default on error
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        isRunning.set(false)
        monitorJob?.cancel()
        scope.cancel()
        Log.d(TAG, "FileMonitorService destroyed")
    }
}